esphome:
  name: s3-synthalia
  friendly_name: S3 Synthalia

  on_boot:
    priority: -100
    then:
      - delay: 1s
      - light.turn_off: onboard_rgb
      - lambda: |-
          ESP_LOGI("BOOT", "ðŸ‘‹ S3 SYNTHALIA - 4D EFFECTS EDITION");
          id(boot_rainbow).execute();

external_components:
  - source: github://soldierkam/vl53l1x_sensor
    refresh: 0s

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

psram:
  mode: octal
  speed: 80MHz

logger:
  level: INFO
  logs:
    sensor: INFO
    vl53l1x_sensor: WARN 

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

api:
  encryption:
    key: !secret s3_synthalia_api_key

ota:
  platform: esphome

i2c:
  sda: GPIO4
  scl: GPIO5
  scan: true
  id: bus_a
  frequency: 400kHz

light:
  # 1. LED ONBOARD (Status Indicator)
  - platform: esp32_rmt_led_strip
    rmt_channel: 0
    rgb_order: GRB
    pin: GPIO48
    num_leds: 1
    chipset: ws2812
    internal: true
    restore_mode: ALWAYS_OFF
    name: "S3 Synthalia Onboard"
    id: onboard_rgb
    effects:
      - pulse:

  # 2. STRISCIA PRINCIPALE (Synthalia da 5 Metri)
  - platform: esp32_rmt_led_strip
    rmt_channel: 1
    rgb_order: GRB
    pin: GPIO13
    num_leds: 300
    chipset: ws2812
    name: "Synthalia Main Strip"
    id: main_strip
    color_correct: [50%, 50%, 50%] 
    gamma_correct: 1.0
    effects:
      - addressable_rainbow:
          name: Rainbow
      
      # -----------------------------------------------------
      # EFFETTO 0: CANDY CANE (Ultra Morbido e Lento)
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Candy Cane"
          update_interval: 16ms
          lambda: |-
            static float current_pos = 0;
            static float auto_pos = 0;
            
            if (id(hand_present)) {
               float target = id(hand_position) * it.size();
               current_pos += (target - current_pos) * 0.005; 
               auto_pos = current_pos; 
            } else {
               auto_pos += 0.03; 
               current_pos = auto_pos;
            }
            
            int stripe_width = 25; 
            for (int i = 0; i < it.size(); i++) {
              int pos = (i + (int)current_pos) % (stripe_width * 2);
              if (pos < stripe_width) {
                 it[i] = Color(255, 0, 0); 
              } else {
                 it[i] = Color(255, 255, 255); 
              }
            }

      # -----------------------------------------------------
      # EFFETTO 1: AURORA BOREALE
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Aurora"
          update_interval: 16ms
          lambda: |-
            static float time_t = 0;
            time_t += 0.01; 
            static float center_pos = it.size() / 2.0;
            static float auto_pos = 0;
            
            if (id(hand_present)) {
               float target = id(hand_position) * it.size();
               center_pos += (target - center_pos) * 0.03; 
               auto_pos = center_pos;
            } else {
               auto_pos += 0.15; 
               center_pos = auto_pos;
            }
            
            for (int i = 0; i < it.size(); i++) {
               float wave1 = sin((i - center_pos) * 0.03 + time_t);
               float wave2 = sin((i + center_pos * 0.5) * 0.02 - time_t * 1.5);
               float combined = (wave1 + wave2) * 0.5; 
               float v = (combined + 1.0) * 0.5;
               
               int r = 0, g = 0, b = 0;
               if (v < 0.4) {
                  float pct = v / 0.4; g = 255 * pct; b = 255;
               } else if (v < 0.7) {
                  float pct = (v - 0.4) / 0.3; g = 255; b = 255 * (1.0 - pct);
               } else {
                  float pct = (v - 0.7) / 0.3; r = 150 * pct; g = 255 * (1.0 - pct); b = 200 * pct;
               }
               it[i] = Color(r, g, b);
            }

      # -----------------------------------------------------
      # EFFETTO 2: FUOCO (Jedi Blue Fire Mode)
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Fire"
          update_interval: 30ms
          lambda: |-
            int num_leds = it.size();
            static float current_height = num_leds * 0.5;
            float target_height = num_leds * 0.5;
            bool is_jedi = id(hand_present);
            
            if (is_jedi) {
                target_height = id(hand_position) * num_leds;
                if (target_height < 15) target_height = 15; 
            } else {
                static int timer = 0;
                static float rand_h = 0;
                if (timer++ > 5) {
                    rand_h = random(0, (int)(num_leds * 0.3));
                    timer = 0;
                }
                target_height = (num_leds * 0.3) + rand_h; 
            }
            
            current_height += (target_height - current_height) * (is_jedi ? 0.15 : 0.05);
            
            for (int i = 0; i < num_leds; i++) {
                float heat = 0.0;
                if (i <= current_height) {
                    heat = 1.0 - ((float)i / current_height);
                    float flicker = random(0, 100) / 100.0;
                    if (heat < 0.8) heat -= flicker * 0.4;
                }
                if (heat < 0.0) heat = 0.0;
                
                int r = 0, g = 0, b = 0;
                if (is_jedi) {
                   if (heat > 0.9) { r = 150; g = 200; b = 255; } 
                   else if (heat > 0.4) { r = 100; g = 50; b = 255; } 
                   else { r = 0; g = 0; b = heat * 255; } 
                } else {
                   if (heat > 0.9) { r = 255; g = 255; b = 150; } 
                   else if (heat > 0.4) { r = 255; g = (heat - 0.4) * (255.0 / 0.6); b = 0; } 
                   else { r = heat * (255.0 / 0.4); g = 0; b = 0; }
                }
                it[i] = Color(r, g, b);
            }

      # -----------------------------------------------------
      # EFFETTO 3: MATRIX DNA (Rimbalzo AntigravitÃ )
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Matrix"
          update_interval: 16ms
          lambda: |-
            int num_leds = it.size();
            static float drops[6] = {50, 100, 150, 200, 250, 300};
            static float speeds[6] = {0.3, 0.5, 0.2, 0.4, 0.6, 0.3};
            static int dirs[6] = {-1, -1, -1, -1, -1, -1};
            
            for(int i=0; i<num_leds; i++) {
                it[i].fade_to_black(20);
            }
            
            float floor_pos = -1;
            if (id(hand_present)) floor_pos = id(hand_position) * num_leds;
            
            for (int j=0; j<6; j++) {
                drops[j] += speeds[j] * dirs[j];
                
                if (dirs[j] == -1 && floor_pos >= 0 && drops[j] <= floor_pos) {
                    dirs[j] = 1; 
                    int p = (int)floor_pos;
                    if (p >= 0 && p < num_leds) it[p] = Color(255, 255, 255); 
                } 
                else if (dirs[j] == -1 && drops[j] < 0) {
                    drops[j] = num_leds + random(0, 50);
                    speeds[j] = random(2, 6) / 10.0;
                }
                else if (dirs[j] == 1 && drops[j] >= num_leds) {
                    dirs[j] = -1; 
                    drops[j] = num_leds;
                }
                
                int p = (int)drops[j];
                if (p >= 0 && p < num_leds) {
                    if (dirs[j] == -1) it[p] = Color(0, 255, 50); 
                    else it[p] = Color(0, 200, 255); 
                }
            }

globals:
  - id: current_mode
    type: int
    initial_value: '0' 
  - id: current_effect
    type: int
    initial_value: '0' 
  - id: hand_position
    type: float
    initial_value: '0.0'
  - id: local_brightness
    type: int
    initial_value: '128'
  - id: local_hue
    type: float
    initial_value: '0.0'
  - id: knob_is_moving
    type: bool
    initial_value: 'false'
  - id: hand_present
    type: bool
    initial_value: 'false'
  - id: gesture_log_tick
    type: int
    initial_value: '0'

sensor:
  - platform: vl53l1x_sensor
    name: "ToF Distance"
    id: tof_dist
    i2c_id: bus_a
    address: 0x29
    distance_mode: MEDIUM
    timing_budget: 20ms
    update_interval: 0.03s
    roi_center: {x: 8, y: 8}
    roi_size: {x: 4, y: 4}
    filters:
      - sliding_window_moving_average: {window_size: 3, send_every: 1}
    on_value:
      then:
        - lambda: |-
            const float min_dist_m = 0.10f;      // 10 cm => 0%
            const float max_dist_m = 0.70f;      // 70 cm => 100%
            const float release_dist_m = 0.78f;  // oltre, mano assente

            bool no_hand = std::isnan(x) || x > release_dist_m;

            if (no_hand) {
               if (id(hand_present)) {
                   id(hand_present) = false;
                   id(gesture_log_tick) = 0;
                   ESP_LOGI("AIR", "ðŸ’¨ Mano persa (> %.0f cm). Mantengo valore corrente.", release_dist_m * 100.0f);
               }
               return; 
            }

            float dist = x;
            float raw_value = (dist - min_dist_m) / (max_dist_m - min_dist_m);
            if (raw_value < 0.0f) raw_value = 0.0f;
            if (raw_value > 1.0f) raw_value = 1.0f;

            if (!id(hand_present)) {
                id(hand_present) = true;
                if (id(current_mode) == 0) {
                    id(hand_position) = id(local_brightness) / 255.0f;
                } else if (id(current_mode) == 1) {
                    id(hand_position) = id(local_hue) / 360.0f;
                } else {
                    id(hand_position) = raw_value;
                }
                ESP_LOGI("AIR", "ðŸ‘‹ Mano rilevata a %.1f cm (range attivo %.0f-%.0f cm).", dist * 100.0f, min_dist_m * 100.0f, max_dist_m * 100.0f);
                id(feedback_hand_detected).execute();
            } else {
                float current = id(hand_position);
                float delta = raw_value - current;
                if (fabsf(delta) < 0.003f) delta = 0.0f;  // anti tremolio leggero

                float alpha = 0.16f;  // smooth generale
                if (fabsf(delta) > 0.08f) alpha = 0.22f;  // un filo piÃ¹ rapido sui cambi grandi

                float next = current + delta * alpha;
                float max_step = 0.018f;  // limita salti per evitare scatti percepibili
                if (next > current + max_step) next = current + max_step;
                if (next < current - max_step) next = current - max_step;
                id(hand_position) = next;
            }
            float value = id(hand_position);

            id(gesture_log_tick) += 1;
            if (id(gesture_log_tick) >= 4) {
                id(gesture_log_tick) = 0;
                int raw_pct = (int)(raw_value * 100.0f + 0.5f);
                int value_pct = (int)(value * 100.0f + 0.5f);
                if (id(current_mode) == 0) {
                    ESP_LOGI("GESTURE", "DIM %.1f cm | raw=%d%% filt=%d%%", dist * 100.0f, raw_pct, value_pct);
                } else if (id(current_mode) == 1) {
                    int hue_deg = (int)(value * 360.0f + 0.5f);
                    ESP_LOGI("GESTURE", "COLOR %.1f cm | raw=%d%% filt=%d%% -> hue=%dÂ°", dist * 100.0f, raw_pct, value_pct, hue_deg);
                } else {
                    int fx_id = id(current_effect);
                    const char *fx_name = "Candy Cane";
                    if (fx_id == 1) fx_name = "Aurora";
                    else if (fx_id == 2) fx_name = "Fire";
                    else if (fx_id == 3) fx_name = "Matrix";
                    ESP_LOGI("GESTURE", "FX %.1f cm | raw=%d%% filt=%d%% -> %s", dist * 100.0f, raw_pct, value_pct, fx_name);
                }
            }

            if (id(current_mode) == 2) return;
            auto call = id(main_strip).turn_on();
            call.set_transition_length(0);

            if (id(current_mode) == 0) {
                id(local_brightness) = (int)(value * 255.0f + 0.5f);
                call.set_rgb(1.0, 1.0, 1.0);
                call.set_brightness(value);
                if (value <= 0.003f) { id(main_strip).turn_off().perform(); return; }
            } else if (id(current_mode) == 1) {
                id(local_hue) = value * 360.0;
                float h = id(local_hue);
                float x_color = (1.0 - fabs(fmod(h / 60.0, 2.0) - 1.0));
                float r=0,g=0,b=0;
                if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
                else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
                call.set_rgb(r, g, b);
                call.set_brightness(id(local_brightness) / 255.0);
            }
            call.perform();

  # 3. ROTARY ENCODER
  - platform: rotary_encoder
    name: "Knob Dimmer"
    id: knob_dimmer
    pin_a: { number: 12, mode: INPUT_PULLUP }
    pin_b: { number: 11, mode: INPUT_PULLUP }
    resolution: 1
    filters:
      - debounce: 5ms
    on_clockwise:
      - lambda: |-
          id(knob_is_moving) = true;
          id(reset_moving_flag).execute();
          
          if (id(current_mode) == 2) {
             id(current_effect) += 1;
             if (id(current_effect) > 3) id(current_effect) = 0; 
             id(apply_effect).execute();
             return; 
          }
          
          auto call = id(main_strip).turn_on();
          call.set_transition_length(100);
          if (id(current_mode) == 0) {
            id(local_brightness) += 15;
            if (id(local_brightness) > 255) id(local_brightness) = 255;
            call.set_brightness(id(local_brightness) / 255.0);
          } else {
            id(local_hue) += 15.0;
            if (id(local_hue) >= 360.0) id(local_hue) -= 360.0;
            float h = id(local_hue);
            float x_color = (1.0 - fabs(fmod(h / 60.0, 2.0) - 1.0));
            float r=0,g=0,b=0;
            if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
            else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
            call.set_rgb(r, g, b);
          }
          call.perform();

    on_anticlockwise:
      - lambda: |-
          id(knob_is_moving) = true;
          id(reset_moving_flag).execute();
          
          if (id(current_mode) == 2) {
             id(current_effect) -= 1;
             if (id(current_effect) < 0) id(current_effect) = 3; 
             id(apply_effect).execute();
             return;
          }
          
          if (id(current_mode) == 0) {
            id(local_brightness) -= 15;
            if (id(local_brightness) <= 0) {
               id(local_brightness) = 0;
               id(main_strip).turn_off().perform();
               return;
            }
          } else {
            id(local_hue) -= 15.0;
            if (id(local_hue) < 0.0) id(local_hue) += 360.0;
          }
          
          auto call = id(main_strip).turn_on();
          call.set_transition_length(100);
          if (id(current_mode) == 0) {
             call.set_brightness(id(local_brightness) / 255.0);
          } else {
             float h = id(local_hue);
             float x_color = (1.0 - fabs(fmod(h / 60.0, 2.0) - 1.0));
             float r=0,g=0,b=0;
             if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
             else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
             call.set_rgb(r, g, b);
          }
          call.perform();

# --- PULSANTE (Multi-Click) ---
binary_sensor:
  - platform: gpio
    pin: { number: 10, mode: INPUT_PULLUP, inverted: true }
    name: "Knob Button"
    filters: 
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_multi_click:
      - timing:
          - ON for at most 0.4s
          - OFF for at most 0.4s
          - ON for at most 0.4s
          - OFF for at least 0.2s
        then:
          - lambda: |-
              ESP_LOGI("BTN", "ðŸŸª MODALITÃ€: EFFETTI (Doppio Click)");
              id(current_mode) = 2; 
              id(feedback_mode_effects).execute();
              id(apply_effect).execute();
      - timing:
          - ON for at most 0.4s
          - OFF for at least 0.2s
        then:
          - lambda: |-
              if (id(current_mode) == 2) {
                 ESP_LOGI("BTN", "â¬œï¸ MODALITÃ€: LUMINOSITÃ€ (Uscita Effetti)");
                 auto call = id(main_strip).turn_on();
                 call.set_effect("None");
                 call.perform();
                 id(current_mode) = 0;
                 id(feedback_mode_bright).execute();
              } else if (id(current_mode) == 0) {
                 ESP_LOGI("BTN", "ðŸŸ¦ MODALITÃ€: COLORE");
                 id(current_mode) = 1;
                 id(feedback_mode_color).execute();
              } else {
                 ESP_LOGI("BTN", "â¬œï¸ MODALITÃ€: LUMINOSITÃ€");
                 id(current_mode) = 0;
                 id(feedback_mode_bright).execute();
              }

# --- SCRIPTS ---
script:
  - id: apply_effect
    mode: restart
    then:
      - lambda: |-
          auto call = id(main_strip).turn_on();
          call.set_brightness(1.0); 
          if (id(current_effect) == 0) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: CANDY CANE");
             call.set_effect("Interactive Candy Cane");
          } else if (id(current_effect) == 1) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: AURORA");
             call.set_effect("Interactive Aurora");
          } else if (id(current_effect) == 2) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: FIRE (Fuoco Vivo)");
             call.set_effect("Interactive Fire");
          } else if (id(current_effect) == 3) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: MATRIX DNA");
             call.set_effect("Interactive Matrix");
          }
          call.perform();

  - id: reset_moving_flag
    mode: restart
    then:
      - delay: 1s
      - lambda: 'id(knob_is_moving) = false;'

  - id: boot_rainbow
    then:
      - light.turn_on: {id: main_strip, brightness: 50%, effect: Rainbow}
      - delay: 2s
      - light.turn_off: main_strip

  - id: feedback_mode_bright
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback modalitÃ  luminositÃ  (LED onboard disabilitato).");'

  - id: feedback_mode_color
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback modalitÃ  colore (LED onboard disabilitato).");'

  - id: feedback_mode_effects
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback modalitÃ  effetti (LED onboard disabilitato).");'

  - id: feedback_hand_detected
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback mano rilevata (LED onboard disabilitato).");'

  - id: feedback_double_blink
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback conferma disattivato (gesture continuo).");'
