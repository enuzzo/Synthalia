esphome:
  name: s3-synthalia
  friendly_name: S3 Synthalia

  on_boot:
    priority: -100
    then:
      - delay: 1s
      - light.turn_off: onboard_rgb
      - lambda: |-
          ESP_LOGI("BOOT", "ðŸ‘‹ S3 SYNTHALIA - 7D EFFECTS EDITION");
          id(boot_rainbow).execute();

external_components:
  - source: github://soldierkam/vl53l1x_sensor
    refresh: 0s

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

psram:
  mode: octal
  speed: 80MHz

logger:
  level: INFO
  logs:
    sensor: INFO
    vl53l1x_sensor: WARN 

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

api:
  encryption:
    key: !secret s3_synthalia_api_key

ota:
  platform: esphome

i2c:
  sda: GPIO4
  scl: GPIO5
  scan: true
  id: bus_a
  frequency: 400kHz

light:
  # 1. LED ONBOARD (Status Indicator)
  - platform: esp32_rmt_led_strip
    rmt_channel: 0
    rgb_order: GRB
    pin: GPIO48
    num_leds: 1
    chipset: ws2812
    internal: true
    restore_mode: ALWAYS_OFF
    name: "S3 Synthalia Onboard"
    id: onboard_rgb
    effects:
      - pulse:

  # 2. STRISCIA PRINCIPALE (Synthalia da 5 Metri)
  - platform: esp32_rmt_led_strip
    rmt_channel: 1
    rgb_order: GRB
    pin: GPIO13
    num_leds: 300
    chipset: ws2812
    name: "Synthalia Main Strip"
    id: main_strip
    color_correct: [50%, 50%, 50%] 
    gamma_correct: 1.0
    effects:
      - addressable_rainbow:
          name: Rainbow
      
      # -----------------------------------------------------
      # EFFETTO 0: CANDY CANE (Ultra Morbido e Lento)
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Candy Cane"
          update_interval: 16ms
          lambda: |-
            static float phase = 0.0f;
            static float auto_phase = 0.0f;
            
            if (id(hand_present)) {
               float target = id(hand_position) * it.size();
               phase += (target - phase) * 0.05f;  // piÃ¹ morbido sul gesto
               auto_phase = phase;
            } else {
               auto_phase += 0.09f;  // scorrimento idle piÃ¹ vellutato
               phase = auto_phase;
            }

            const float stripe_period = 52.0f;  // bande piÃ¹ ampie, meno "ingranaggio"
            const float k = 2.0f * 3.14159265f / stripe_period;
            for (int i = 0; i < it.size(); i++) {
              float wave = 0.5f + 0.5f * sinf((i + phase) * k);  // 0..1 continuo
              float blend = wave * wave * (3.0f - 2.0f * wave); // smoothstep
              uint8_t gb = (uint8_t)(255.0f * (1.0f - blend));
              it[i] = Color(255, gb, gb);  // rosso <-> bianco con gradiente morbido
            }

      # -----------------------------------------------------
      # EFFETTO 1: AURORA BOREALE
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Aurora"
          update_interval: 16ms
          lambda: |-
            static float time_t = 0;
            time_t += 0.01; 
            static float center_pos = it.size() / 2.0;
            static float auto_pos = 0;
            
            if (id(hand_present)) {
               float target = id(hand_position) * it.size();
               center_pos += (target - center_pos) * 0.03; 
               auto_pos = center_pos;
            } else {
               auto_pos += 0.15; 
               center_pos = auto_pos;
            }
            
            for (int i = 0; i < it.size(); i++) {
               float wave1 = sin((i - center_pos) * 0.03 + time_t);
               float wave2 = sin((i + center_pos * 0.5) * 0.02 - time_t * 1.5);
               float combined = (wave1 + wave2) * 0.5; 
               float v = (combined + 1.0) * 0.5;
               
               int r = 0, g = 0, b = 0;
               if (v < 0.4) {
                  float pct = v / 0.4; g = 255 * pct; b = 255;
               } else if (v < 0.7) {
                  float pct = (v - 0.4) / 0.3; g = 255; b = 255 * (1.0 - pct);
               } else {
                  float pct = (v - 0.7) / 0.3; r = 150 * pct; g = 255 * (1.0 - pct); b = 200 * pct;
               }
               it[i] = Color(r, g, b);
            }

      # -----------------------------------------------------
      # EFFETTO 2: MATRIX DNA (Interazione Mano Potenziata)
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Matrix"
          update_interval: 16ms
          lambda: |-
            int num_leds = it.size();
            static float drops[6] = {50, 100, 150, 200, 250, 300};
            static float speeds[6] = {0.30f, 0.48f, 0.24f, 0.40f, 0.56f, 0.34f};
            static int dirs[6] = {-1, -1, -1, -1, -1, -1};
            static float wall_smooth = -1.0f;
            const float speed_scale = 0.85f;  // ~15% piÃ¹ lento

            for (int i = 0; i < num_leds; i++) {
                it[i].fade_to_black(24);
            }

            auto add_px = [&](int idx, uint8_t r, uint8_t g, uint8_t b) {
                int nr = it[idx].get_red() + r;
                int ng = it[idx].get_green() + g;
                int nb = it[idx].get_blue() + b;
                if (nr > 255) nr = 255;
                if (ng > 255) ng = 255;
                if (nb > 255) nb = 255;
                it[idx] = Color(nr, ng, nb);
            };

            float wall_pos = -1.0f;
            if (id(hand_present)) {
                float target_wall = id(hand_position) * (num_leds - 1);
                if (wall_smooth < 0.0f) wall_smooth = target_wall;
                wall_smooth += (target_wall - wall_smooth) * 0.30f;
                wall_pos = wall_smooth;

                // Muro visivo della mano: piÃ¹ largo e piÃ¹ evidente.
                int center = (int)wall_pos;
                for (int d = -10; d <= 10; d++) {
                    int p = center + d;
                    if (p < 0 || p >= num_leds) continue;
                    float dist = fabsf((float)d);
                    float intensity = 1.0f - (dist / 10.0f);
                    if (intensity < 0.0f) intensity = 0.0f;
                    uint8_t g = (uint8_t)(80.0f + 120.0f * intensity);
                    uint8_t b = (uint8_t)(120.0f + 135.0f * intensity);
                    add_px(p, 0, g, b);
                }
            } else {
                wall_smooth = -1.0f;
            }

            for (int j = 0; j < 6; j++) {
                float speed = speeds[j] * speed_scale;

                if (dirs[j] == -1 && wall_pos >= 0.0f) {
                    float dist_to_wall = drops[j] - wall_pos;
                    if (dist_to_wall > 0.0f && dist_to_wall < 14.0f) {
                        float t = 1.0f - (dist_to_wall / 14.0f);
                        speed *= (1.0f - 0.45f * t);  // rallenta avvicinandosi alla mano
                    }
                }

                drops[j] += speed * dirs[j];

                if (dirs[j] == -1 && wall_pos >= 0.0f && drops[j] <= wall_pos) {
                    dirs[j] = 1;
                    drops[j] = wall_pos + 0.2f;
                    int p = (int)wall_pos;
                    for (int d = -4; d <= 4; d++) {
                        int pp = p + d;
                        if (pp < 0 || pp >= num_leds) continue;
                        float intensity = 1.0f - (fabsf((float)d) / 4.5f);
                        if (intensity < 0.0f) intensity = 0.0f;
                        add_px(pp, (uint8_t)(180.0f * intensity), (uint8_t)(220.0f * intensity), (uint8_t)(255.0f * intensity));
                    }
                } else if (dirs[j] == -1 && drops[j] < 0) {
                    drops[j] = num_leds + random(0, 50);
                    speeds[j] = random(2, 6) / 10.0f;
                } else if (dirs[j] == 1 && drops[j] >= num_leds) {
                    dirs[j] = -1;
                    drops[j] = num_leds + random(0, 40);
                }

                int p = (int)drops[j];
                for (int t = 0; t < 3; t++) {
                    int pp = p - t * dirs[j];
                    if (pp < 0 || pp >= num_leds) continue;
                    float trail = 1.0f - (t * 0.35f);
                    if (trail < 0.0f) trail = 0.0f;
                    if (dirs[j] == -1) {
                        add_px(pp, 0, (uint8_t)(255.0f * trail), (uint8_t)(40.0f * trail));
                    } else {
                        add_px(pp, 0, (uint8_t)(170.0f * trail), (uint8_t)(255.0f * trail));
                    }
                }
            }

      # -----------------------------------------------------
      # EFFETTO 3: FUOCO (Morbido e Reattivo)
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Fire"
          update_interval: 30ms
          lambda: |-
            const int max_leds = 300;
            int n = it.size();
            if (n > max_leds) n = max_leds;

            static float heat[max_leds] = {0.0f};
            static float shown[max_leds] = {0.0f};
            static float height_ctrl = 0.42f;
            static float dim_ctrl = 0.82f;
            static float idle_height_target = 0.42f;
            static int idle_tick = 0;

            if (id(hand_present)) {
                float t = id(hand_position);
                if (t < 0.0f) t = 0.0f;
                if (t > 1.0f) t = 1.0f;
                // Controllo principalmente l'altezza fiamma (piÃ¹ diretto).
                height_ctrl += (t - height_ctrl) * 0.18f;
                // E in parallelo un dimming leggero per rendere il gesto piÃ¹ evidente.
                float dim_target = 0.45f + t * 0.55f;  // 45%..100%
                dim_ctrl += (dim_target - dim_ctrl) * 0.16f;
            } else {
                if (idle_tick++ > 45) {
                    idle_tick = 0;
                    idle_height_target = 0.32f + (random(0, 31) / 100.0f);  // 0.32..0.62
                }
                height_ctrl += (idle_height_target - height_ctrl) * 0.03f;
                float idle_dim_target = 0.80f + height_ctrl * 0.12f;
                dim_ctrl += (idle_dim_target - dim_ctrl) * 0.04f;
            }

            float flame_height = (0.14f + height_ctrl * 0.86f) * n;
            float cooling_base = 0.006f;
            float cooling_var = 0.006f;
            float spark_strength = 0.22f;
            float spark_chance = 0.075f;
            int spark_zone = 7;
            if (spark_zone > n) spark_zone = n;

            // 1) Raffreddamento dolce.
            for (int i = 0; i < n; i++) {
                float cool = cooling_base + (random(0, 100) / 100.0f) * cooling_var;
                heat[i] -= cool;
                if (heat[i] < 0.0f) heat[i] = 0.0f;
            }

            // 2) Diffusione verticale.
            for (int k = n - 1; k >= 2; k--) {
                heat[k] = (heat[k] + heat[k - 1] * 2.0f + heat[k - 2]) * 0.25f;
            }

            // 3) Poche scintille alla base (niente flash aggressivi).
            if (random(0, 1000) < (int)(spark_chance * 1000.0f)) {
                int sparks = (random(0, 1000) < 60) ? 2 : 1;
                for (int s = 0; s < sparks; s++) {
                    int y = random(0, spark_zone);
                    float add = spark_strength * (0.78f + random(0, 20) / 100.0f);
                    heat[y] += add;
                    if (heat[y] > 1.0f) heat[y] = 1.0f;
                }
            }

            // 4) Smussa temporalmente per eliminare micro-lampeggi.
            for (int i = 0; i < n; i++) {
                shown[i] += (heat[i] - shown[i]) * 0.22f;
            }

            // 5) Mappa calore -> colore fuoco, con envelope di altezza.
            for (int i = 0; i < n; i++) {
                float h = shown[i];
                float pos = (flame_height > 1.0f) ? ((float)i / flame_height) : 1.0f;
                float envelope = 1.0f;
                if (pos > 1.0f) {
                    envelope = 1.0f - (pos - 1.0f) * 3.4f;
                    if (envelope < 0.0f) envelope = 0.0f;
                } else {
                    envelope = 1.0f - pos * 0.12f;
                }
                h *= envelope;
                if (h < 0.0f) h = 0.0f;
                if (h > 1.0f) h = 1.0f;

                uint8_t r = 0, g = 0, b = 0;
                if (h < 0.40f) {
                    float t = h / 0.40f;
                    r = (uint8_t)(35.0f + 175.0f * t);
                    g = (uint8_t)(4.0f + 36.0f * t);
                } else if (h < 0.80f) {
                    float t = (h - 0.40f) / 0.40f;
                    r = (uint8_t)(210.0f + 45.0f * t);
                    g = (uint8_t)(40.0f + 140.0f * t);
                } else {
                    float t = (h - 0.80f) / 0.20f;
                    r = 255;
                    g = (uint8_t)(180.0f + 75.0f * t);
                    b = (uint8_t)(18.0f * t);
                }
                r = (uint8_t)((float)r * dim_ctrl);
                g = (uint8_t)((float)g * dim_ctrl);
                b = (uint8_t)((float)b * dim_ctrl);
                it[i] = Color(r, g, b);
            }

            for (int i = n; i < it.size(); i++) {
                it[i] = Color(0, 0, 0);
            }

      # -----------------------------------------------------
      # EFFETTO 4: PLASMA VORTEX (Organico + Reattivo)
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Plasma Vortex"
          update_interval: 16ms
          lambda: |-
            int n = it.size();
            if (n <= 0) return;

            static float time_t = 0.0f;
            static float ctrl = 0.5f;
            static float auto_ctrl = 0.5f;
            time_t += 0.030f;

            if (id(hand_present)) {
                float target = id(hand_position);
                if (target < 0.0f) target = 0.0f;
                if (target > 1.0f) target = 1.0f;
                ctrl += (target - ctrl) * 0.10f;
                auto_ctrl = ctrl;
            } else {
                float idle_target = 0.5f + 0.35f * sinf(time_t * 0.7f);
                auto_ctrl += (idle_target - auto_ctrl) * 0.02f;
                ctrl = auto_ctrl;
            }

            auto hsv_to_rgb = [&](float h_deg, float s, float v, uint8_t &r, uint8_t &g, uint8_t &b) {
                while (h_deg < 0.0f) h_deg += 360.0f;
                while (h_deg >= 360.0f) h_deg -= 360.0f;
                if (s < 0.0f) s = 0.0f;
                if (s > 1.0f) s = 1.0f;
                if (v < 0.0f) v = 0.0f;
                if (v > 1.0f) v = 1.0f;

                float c = v * s;
                float x = c * (1.0f - fabsf(fmodf(h_deg / 60.0f, 2.0f) - 1.0f));
                float m = v - c;
                float rp = 0.0f, gp = 0.0f, bp = 0.0f;

                if (h_deg < 60.0f) { rp = c; gp = x; }
                else if (h_deg < 120.0f) { rp = x; gp = c; }
                else if (h_deg < 180.0f) { gp = c; bp = x; }
                else if (h_deg < 240.0f) { gp = x; bp = c; }
                else if (h_deg < 300.0f) { rp = x; bp = c; }
                else { rp = c; bp = x; }

                r = (uint8_t)((rp + m) * 255.0f);
                g = (uint8_t)((gp + m) * 255.0f);
                b = (uint8_t)((bp + m) * 255.0f);
            };

            float center = ctrl * (n - 1);
            for (int i = 0; i < n; i++) {
                float x = (float)i / (float)n;
                float d = ((float)i - center) / ((float)n * 0.5f);

                float swirl = sinf((x * 16.0f + time_t * 1.4f) + d * 6.0f);
                float bands = sinf((x * 7.0f - time_t * 1.9f) - d * 3.5f);
                float detail = sinf((x * 31.0f + time_t * 0.8f) + ctrl * 5.0f);

                float mix = (swirl * 0.55f + bands * 0.35f + detail * 0.20f) / 1.10f;
                float v = 0.5f + 0.5f * mix;
                if (v < 0.0f) v = 0.0f;
                if (v > 1.0f) v = 1.0f;

                float hue = 180.0f + v * 160.0f + 28.0f * sinf(d * 4.0f + time_t * 2.2f);
                float sat = 0.82f + 0.18f * (1.0f - fabsf(d));
                if (sat < 0.65f) sat = 0.65f;
                if (sat > 1.0f) sat = 1.0f;
                float val = 0.18f + 0.82f * v;

                uint8_t r, g, b;
                hsv_to_rgb(hue, sat, val, r, g, b);
                it[i] = Color(r, g, b);
            }

      # -----------------------------------------------------
      # EFFETTO 5: COMET RAIN (Scie Dinamiche)
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Comet Rain"
          update_interval: 16ms
          lambda: |-
            const int comet_count = 7;
            int n = it.size();
            if (n <= 0) return;

            static bool initialized = false;
            static float heads[comet_count];
            static float speeds[comet_count];
            static float hues[comet_count];
            static float speed_ctrl = 0.55f;
            static float trail_ctrl = 10.0f;
            static float hue_shift = 0.0f;
            static float idle_phase = 0.0f;

            if (!initialized) {
                initialized = true;
                for (int j = 0; j < comet_count; j++) {
                    heads[j] = random(0, n);
                    speeds[j] = 0.55f + random(0, 95) / 100.0f;
                    hues[j] = 170.0f + random(0, 140);
                }
            }

            for (int i = 0; i < n; i++) {
                it[i].fade_to_black(34);
            }

            if (id(hand_present)) {
                float t = id(hand_position);
                if (t < 0.0f) t = 0.0f;
                if (t > 1.0f) t = 1.0f;
                float target_speed = 0.25f + t * 1.45f;
                float target_trail = 6.0f + t * 14.0f;
                speed_ctrl += (target_speed - speed_ctrl) * 0.18f;
                trail_ctrl += (target_trail - trail_ctrl) * 0.14f;
            } else {
                idle_phase += 0.015f;
                float idle_speed = 0.48f + 0.14f * sinf(idle_phase);
                speed_ctrl += (idle_speed - speed_ctrl) * 0.04f;
                trail_ctrl += (9.5f - trail_ctrl) * 0.05f;
            }

            hue_shift += 0.35f;
            if (hue_shift >= 360.0f) hue_shift -= 360.0f;

            auto hsv_to_rgb = [&](float h_deg, float s, float v, uint8_t &r, uint8_t &g, uint8_t &b) {
                while (h_deg < 0.0f) h_deg += 360.0f;
                while (h_deg >= 360.0f) h_deg -= 360.0f;
                if (s < 0.0f) s = 0.0f;
                if (s > 1.0f) s = 1.0f;
                if (v < 0.0f) v = 0.0f;
                if (v > 1.0f) v = 1.0f;

                float c = v * s;
                float x = c * (1.0f - fabsf(fmodf(h_deg / 60.0f, 2.0f) - 1.0f));
                float m = v - c;
                float rp = 0.0f, gp = 0.0f, bp = 0.0f;

                if (h_deg < 60.0f) { rp = c; gp = x; }
                else if (h_deg < 120.0f) { rp = x; gp = c; }
                else if (h_deg < 180.0f) { gp = c; bp = x; }
                else if (h_deg < 240.0f) { gp = x; bp = c; }
                else if (h_deg < 300.0f) { rp = x; bp = c; }
                else { rp = c; bp = x; }

                r = (uint8_t)((rp + m) * 255.0f);
                g = (uint8_t)((gp + m) * 255.0f);
                b = (uint8_t)((bp + m) * 255.0f);
            };

            int trail_len = (int)trail_ctrl;
            if (trail_len < 3) trail_len = 3;
            if (trail_len > 20) trail_len = 20;

            for (int j = 0; j < comet_count; j++) {
                heads[j] += speeds[j] * speed_ctrl;
                if (heads[j] >= (float)(n + trail_len)) {
                    heads[j] -= (float)(n + trail_len);
                    speeds[j] = 0.55f + random(0, 95) / 100.0f;
                    hues[j] += 40.0f + random(0, 90);
                    while (hues[j] >= 360.0f) hues[j] -= 360.0f;
                }

                for (int t = 0; t < trail_len; t++) {
                    int idx = (int)(heads[j] - (float)t);
                    idx %= n;
                    if (idx < 0) idx += n;

                    float trail = 1.0f - ((float)t / (float)trail_len);
                    float v = trail * trail;
                    if (t == 0) v = 1.0f;
                    float hue = hues[j] + hue_shift + t * 1.5f;

                    uint8_t r, g, b;
                    hsv_to_rgb(hue, 0.95f, v, r, g, b);

                    int nr = it[idx].get_red() + r;
                    int ng = it[idx].get_green() + g;
                    int nb = it[idx].get_blue() + b;
                    if (nr > 255) nr = 255;
                    if (ng > 255) ng = 255;
                    if (nb > 255) nb = 255;
                    it[idx] = Color(nr, ng, nb);
                }
            }

            if (id(hand_present)) {
                int focus = (int)(id(hand_position) * (n - 1));
                for (int d = -6; d <= 6; d++) {
                    int p = focus + d;
                    if (p < 0 || p >= n) continue;
                    float k = 1.0f - fabsf((float)d) / 6.5f;
                    if (k < 0.0f) k = 0.0f;
                    int nr = it[p].get_red() + (int)(90.0f * k);
                    int ng = it[p].get_green() + (int)(140.0f * k);
                    int nb = it[p].get_blue() + (int)(180.0f * k);
                    if (nr > 255) nr = 255;
                    if (ng > 255) ng = 255;
                    if (nb > 255) nb = 255;
                    it[p] = Color(nr, ng, nb);
                }
            }

      # -----------------------------------------------------
      # EFFETTO 6: NEBULA SPARK (Cloud + Twinkle)
      # -----------------------------------------------------
      - addressable_lambda:
          name: "Interactive Nebula Spark"
          update_interval: 22ms
          lambda: |-
            const int max_leds = 300;
            int n = it.size();
            if (n > max_leds) n = max_leds;
            if (n <= 0) return;

            static float cloud[max_leds] = {0.0f};
            static float spark[max_leds] = {0.0f};
            static float drift = 0.0f;
            static float ctrl = 0.5f;
            static float auto_ctrl = 0.5f;

            drift += 0.017f;

            if (id(hand_present)) {
                float target = id(hand_position);
                if (target < 0.0f) target = 0.0f;
                if (target > 1.0f) target = 1.0f;
                ctrl += (target - ctrl) * 0.12f;
                auto_ctrl = ctrl;
            } else {
                float idle_target = 0.5f + 0.25f * sinf(drift * 0.8f);
                auto_ctrl += (idle_target - auto_ctrl) * 0.02f;
                ctrl = auto_ctrl;
            }

            int band_center = (int)(ctrl * (n - 1));
            float band_width = (float)n * (0.22f + 0.24f * ctrl);
            if (band_width < 8.0f) band_width = 8.0f;

            for (int i = 0; i < n; i++) {
                float x = (float)i / (float)n;
                float neb = 0.5f + 0.5f * sinf(x * 10.0f + drift * 1.2f + sinf(x * 4.0f - drift * 0.7f) * 2.0f);
                float focus = 1.0f - fabsf((float)(i - band_center)) / band_width;
                if (focus < 0.0f) focus = 0.0f;

                float target_cloud = 0.08f + neb * (0.42f + 0.48f * focus);
                cloud[i] += (target_cloud - cloud[i]) * 0.14f;

                spark[i] *= 0.86f;
                if (spark[i] < 0.001f) spark[i] = 0.0f;
            }

            int spawn_zone = 14 + (int)(ctrl * 48.0f);
            int spawn_attempts = id(hand_present) ? 4 : 2;
            int spawn_threshold = id(hand_present) ? 190 : 90;  // /1000
            for (int s = 0; s < spawn_attempts; s++) {
                int offset = random(0, spawn_zone * 2 + 1) - spawn_zone;
                int idx = band_center + offset;
                if (idx < 0 || idx >= n) continue;
                if (random(0, 1000) < spawn_threshold) {
                    float add = 0.35f + random(0, 60) / 100.0f;
                    spark[idx] += add;
                    if (spark[idx] > 1.0f) spark[idx] = 1.0f;
                }
            }

            for (int i = 0; i < n; i++) {
                float c = cloud[i];
                float s = spark[i];

                float rf = c * (0.16f + 0.54f * ctrl) + s * 0.70f;
                float gf = c * (0.25f + 0.20f * sinf(drift + i * 0.01f)) + s * 0.82f;
                float bf = c * (0.65f + 0.30f * (1.0f - ctrl)) + s * 1.00f;

                if (rf > 1.0f) rf = 1.0f;
                if (gf > 1.0f) gf = 1.0f;
                if (bf > 1.0f) bf = 1.0f;
                if (rf < 0.0f) rf = 0.0f;
                if (gf < 0.0f) gf = 0.0f;
                if (bf < 0.0f) bf = 0.0f;

                it[i] = Color((uint8_t)(rf * 255.0f), (uint8_t)(gf * 255.0f), (uint8_t)(bf * 255.0f));
            }

            for (int i = n; i < it.size(); i++) {
                it[i] = Color(0, 0, 0);
            }

globals:
  - id: current_mode
    type: int
    initial_value: '0' 
  - id: current_effect
    type: int
    initial_value: '0' 
  - id: hand_position
    type: float
    initial_value: '0.0'
  - id: local_brightness
    type: int
    initial_value: '128'
  - id: local_hue
    type: float
    initial_value: '-1.0'
  - id: knob_is_moving
    type: bool
    initial_value: 'false'
  - id: hand_present
    type: bool
    initial_value: 'false'
  - id: gesture_log_tick
    type: int
    initial_value: '0'

sensor:
  - platform: vl53l1x_sensor
    name: "ToF Distance"
    id: tof_dist
    i2c_id: bus_a
    address: 0x29
    distance_mode: MEDIUM
    timing_budget: 20ms
    update_interval: 0.03s
    roi_center: {x: 8, y: 8}
    roi_size: {x: 4, y: 4}
    filters:
      - sliding_window_moving_average: {window_size: 3, send_every: 1}
    on_value:
      then:
        - lambda: |-
            const float min_dist_m = 0.10f;      // 10 cm => 0%
            const float max_dist_m = 0.70f;      // 70 cm => 100%
            const float release_dist_m = 0.78f;  // oltre, mano assente

            bool no_hand = std::isnan(x) || x > release_dist_m;

            if (no_hand) {
               if (id(hand_present)) {
                   id(hand_present) = false;
                   id(gesture_log_tick) = 0;
                   ESP_LOGI("AIR", "ðŸ’¨ Mano persa (> %.0f cm). Mantengo valore corrente.", release_dist_m * 100.0f);
               }
               return; 
            }

            float dist = x;
            float raw_value = (dist - min_dist_m) / (max_dist_m - min_dist_m);
            if (raw_value < 0.0f) raw_value = 0.0f;
            if (raw_value > 1.0f) raw_value = 1.0f;

            if (!id(hand_present)) {
                id(hand_present) = true;
                if (id(current_mode) == 0) {
                    id(hand_position) = id(local_brightness) / 255.0f;
                } else if (id(current_mode) == 1) {
                    id(hand_position) = id(local_hue) / 360.0f;
                } else {
                    id(hand_position) = raw_value;
                }
                ESP_LOGI("AIR", "ðŸ‘‹ Mano rilevata a %.1f cm (range attivo %.0f-%.0f cm).", dist * 100.0f, min_dist_m * 100.0f, max_dist_m * 100.0f);
                id(feedback_hand_detected).execute();
            } else {
                float current = id(hand_position);
                float delta = raw_value - current;
                if (fabsf(delta) < 0.003f) delta = 0.0f;  // anti tremolio leggero

                float alpha = 0.16f;  // smooth generale
                if (fabsf(delta) > 0.08f) alpha = 0.22f;  // un filo piÃ¹ rapido sui cambi grandi

                float next = current + delta * alpha;
                float max_step = 0.018f;  // limita salti per evitare scatti percepibili
                if (next > current + max_step) next = current + max_step;
                if (next < current - max_step) next = current - max_step;
                id(hand_position) = next;
            }
            float value = id(hand_position);

            id(gesture_log_tick) += 1;
            if (id(gesture_log_tick) >= 4) {
                id(gesture_log_tick) = 0;
                int raw_pct = (int)(raw_value * 100.0f + 0.5f);
                int value_pct = (int)(value * 100.0f + 0.5f);
                if (id(current_mode) == 0) {
                    ESP_LOGI("GESTURE", "DIM %.1f cm | raw=%d%% filt=%d%%", dist * 100.0f, raw_pct, value_pct);
                } else if (id(current_mode) == 1) {
                    int hue_deg = (int)(value * 360.0f + 0.5f);
                    ESP_LOGI("GESTURE", "COLOR %.1f cm | raw=%d%% filt=%d%% -> hue=%dÂ°", dist * 100.0f, raw_pct, value_pct, hue_deg);
                } else {
                    int fx_id = id(current_effect);
                    const char *fx_name = "Candy Cane";
                    if (fx_id == 1) fx_name = "Aurora";
                    else if (fx_id == 2) fx_name = "Matrix";
                    else if (fx_id == 3) fx_name = "Fire";
                    else if (fx_id == 4) fx_name = "Plasma";
                    else if (fx_id == 5) fx_name = "Comet";
                    else if (fx_id == 6) fx_name = "Nebula";
                    ESP_LOGI("GESTURE", "FX %.1f cm | raw=%d%% filt=%d%% -> %s", dist * 100.0f, raw_pct, value_pct, fx_name);
                }
            }

            if (id(current_mode) == 2) return;
            auto call = id(main_strip).turn_on();
            call.set_transition_length(0);

            if (id(current_mode) == 0) {
                id(local_brightness) = (int)(value * 255.0f + 0.5f);
                if (id(local_hue) >= 0.0f) {
                    float h = id(local_hue);
                    float x_color = (1.0f - fabsf(fmodf(h / 60.0f, 2.0f) - 1.0f));
                    float r=0,g=0,b=0;
                    if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
                    else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
                    call.set_rgb(r, g, b);
                } else {
                    call.set_rgb(1.0, 1.0, 1.0);
                }
                call.set_brightness(value);
                if (value <= 0.003f) { id(main_strip).turn_off().perform(); return; }
            } else if (id(current_mode) == 1) {
                id(local_hue) = value * 360.0;
                float h = id(local_hue);
                float x_color = (1.0 - fabs(fmod(h / 60.0, 2.0) - 1.0));
                float r=0,g=0,b=0;
                if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
                else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
                call.set_rgb(r, g, b);
                call.set_brightness(id(local_brightness) / 255.0);
            }
            call.perform();

  # 3. ROTARY ENCODER
  - platform: rotary_encoder
    name: "Knob Dimmer"
    id: knob_dimmer
    pin_a: { number: 12, mode: INPUT_PULLUP }
    pin_b: { number: 11, mode: INPUT_PULLUP }
    resolution: 1
    filters:
      - debounce: 5ms
    on_clockwise:
      - lambda: |-
          id(knob_is_moving) = true;
          id(reset_moving_flag).execute();
          
          if (id(current_mode) == 2) {
             id(current_effect) += 1;
             if (id(current_effect) > 6) id(current_effect) = 0; 
             id(apply_effect).execute();
             return; 
          }
          
          const int knob_step_brightness = 6;
          const float knob_step_hue = 6.0f;
          auto call = id(main_strip).turn_on();
          call.set_transition_length(120);
          if (id(current_mode) == 0) {
            id(local_brightness) += knob_step_brightness;
            if (id(local_brightness) > 255) id(local_brightness) = 255;
            if (id(local_hue) >= 0.0f) {
              float h = id(local_hue);
              float x_color = (1.0f - fabsf(fmodf(h / 60.0f, 2.0f) - 1.0f));
              float r=0,g=0,b=0;
              if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
              else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
              call.set_rgb(r, g, b);
            } else {
              call.set_rgb(1.0, 1.0, 1.0);
            }
            call.set_brightness(id(local_brightness) / 255.0);
          } else {
            id(local_hue) += knob_step_hue;
            if (id(local_hue) >= 360.0) id(local_hue) -= 360.0;
            float h = id(local_hue);
            float x_color = (1.0 - fabs(fmod(h / 60.0, 2.0) - 1.0));
            float r=0,g=0,b=0;
            if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
            else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
            call.set_rgb(r, g, b);
          }
          call.perform();

    on_anticlockwise:
      - lambda: |-
          id(knob_is_moving) = true;
          id(reset_moving_flag).execute();
          
          if (id(current_mode) == 2) {
             id(current_effect) -= 1;
             if (id(current_effect) < 0) id(current_effect) = 6; 
             id(apply_effect).execute();
             return;
          }
          
          const int knob_step_brightness = 6;
          const float knob_step_hue = 6.0f;
          if (id(current_mode) == 0) {
            id(local_brightness) -= knob_step_brightness;
            if (id(local_brightness) <= 0) {
               id(local_brightness) = 0;
               id(main_strip).turn_off().perform();
               return;
            }
          } else {
            id(local_hue) -= knob_step_hue;
            if (id(local_hue) < 0.0) id(local_hue) += 360.0;
          }
          
          auto call = id(main_strip).turn_on();
          call.set_transition_length(120);
          if (id(current_mode) == 0) {
             if (id(local_hue) >= 0.0f) {
                float h = id(local_hue);
                float x_color = (1.0f - fabsf(fmodf(h / 60.0f, 2.0f) - 1.0f));
                float r=0,g=0,b=0;
                if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
                else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
                call.set_rgb(r, g, b);
             } else {
                call.set_rgb(1.0, 1.0, 1.0);
             }
             call.set_brightness(id(local_brightness) / 255.0);
          } else {
             float h = id(local_hue);
             float x_color = (1.0 - fabs(fmod(h / 60.0, 2.0) - 1.0));
             float r=0,g=0,b=0;
             if(h<60){r=1;g=x_color;b=0;}else if(h<120){r=x_color;g=1;b=0;}else if(h<180){r=0;g=1;b=x_color;}
             else if(h<240){r=0;g=x_color;b=1;}else if(h<300){r=x_color;g=0;b=1;}else{r=1;g=0;b=x_color;}
             call.set_rgb(r, g, b);
          }
          call.perform();

# --- PULSANTE (Multi-Click) ---
binary_sensor:
  - platform: gpio
    pin: { number: 10, mode: INPUT_PULLUP, inverted: true }
    name: "Knob Button"
    filters: 
      - delayed_on: 10ms
      - delayed_off: 10ms
    on_multi_click:
      - timing:
          - ON for at most 0.4s
          - OFF for at most 0.4s
          - ON for at most 0.4s
          - OFF for at least 0.2s
        then:
          - lambda: |-
              ESP_LOGI("BTN", "ðŸŸª MODALITÃ€: EFFETTI (Doppio Click)");
              id(current_mode) = 2; 
              id(feedback_mode_effects).execute();
              id(apply_effect).execute();
      - timing:
          - ON for at most 0.4s
          - OFF for at least 0.2s
        then:
          - lambda: |-
              if (id(current_mode) == 2) {
                 ESP_LOGI("BTN", "â¬œï¸ MODALITÃ€: LUMINOSITÃ€ (Uscita Effetti)");
                 auto call = id(main_strip).turn_on();
                 call.set_effect("None");
                 call.perform();
                 id(current_mode) = 0;
                 id(feedback_mode_bright).execute();
              } else if (id(current_mode) == 0) {
                 ESP_LOGI("BTN", "ðŸŸ¦ MODALITÃ€: COLORE");
                 id(current_mode) = 1;
                 id(feedback_mode_color).execute();
              } else {
                 ESP_LOGI("BTN", "â¬œï¸ MODALITÃ€: LUMINOSITÃ€");
                 id(current_mode) = 0;
                 id(feedback_mode_bright).execute();
              }

# --- SCRIPTS ---
script:
  - id: apply_effect
    mode: restart
    then:
      - lambda: |-
          auto call = id(main_strip).turn_on();
          call.set_brightness(1.0); 
          if (id(current_effect) == 0) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: CANDY CANE");
             call.set_effect("Interactive Candy Cane");
          } else if (id(current_effect) == 1) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: AURORA");
             call.set_effect("Interactive Aurora");
          } else if (id(current_effect) == 2) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: MATRIX DNA");
             call.set_effect("Interactive Matrix");
          } else if (id(current_effect) == 3) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: FIRE (Morbido)");
             call.set_effect("Interactive Fire");
          } else if (id(current_effect) == 4) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: PLASMA VORTEX");
             call.set_effect("Interactive Plasma Vortex");
          } else if (id(current_effect) == 5) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: COMET RAIN");
             call.set_effect("Interactive Comet Rain");
          } else if (id(current_effect) == 6) {
             ESP_LOGI("FX", "ðŸŽ¨ Attivato Effetto: NEBULA SPARK");
             call.set_effect("Interactive Nebula Spark");
          }
          call.perform();

  - id: reset_moving_flag
    mode: restart
    then:
      - delay: 1s
      - lambda: 'id(knob_is_moving) = false;'

  - id: boot_rainbow
    then:
      - light.turn_on: {id: main_strip, brightness: 50%, effect: Rainbow}
      - delay: 2s
      - light.turn_off: main_strip

  - id: feedback_mode_bright
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback modalitÃ  luminositÃ  (LED onboard disabilitato).");'

  - id: feedback_mode_color
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback modalitÃ  colore (LED onboard disabilitato).");'

  - id: feedback_mode_effects
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback modalitÃ  effetti (LED onboard disabilitato).");'

  - id: feedback_hand_detected
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback mano rilevata (LED onboard disabilitato).");'

  - id: feedback_double_blink
    mode: restart
    then:
      - lambda: 'ESP_LOGI("LED", "Feedback conferma disattivato (gesture continuo).");'
